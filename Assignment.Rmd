###Read in and tidy data
```{r}
data_raw<-read.csv("data_raw/20230620_L6_Thio_Report_JvGfilt.csv")

str(data_raw)

glimpse(data_raw)

###Rename columns

##Reorder columns

num_cols<-colnames(data_raw[9:37])

num_cols_reorder<-c(num_cols[grep("ctrl_bas", num_cols)],
                    num_cols[grep("ctrl_ins", num_cols)],
                    num_cols[grep("ctrl_thio", num_cols)],
                    num_cols[grep("palm_bas", num_cols)],
                    num_cols[grep("palm_ins", num_cols)],
                    num_cols[grep("palm_thio", num_cols)])

##Implement reordering in our data

data_raw_reorder<-data_raw[,c(colnames(data_raw)[1:8],num_cols_reorder,colnames(data_raw)[38])]

str(data_raw_reorder)

##Tidy up condition names

renaming<-data.frame("old_names"=num_cols_reorder)

renaming$condition<-c(rep("ctrl_bas",5),
                      rep("ctrl_ins",4),
                      rep("ctrl_thio",5),
                      rep("palm_bas",5),
                      rep("palm_ins",5),
                      rep("palm_thio",5))
renaming$n<-c(1:5,
              1,2,4,5,
              1:5,
              1:5,
              1:5,
              1:5)

renaming$new_names<-paste(renaming$condition,renaming$n, sep="_")

colnames(data_raw_reorder)[9:37]<-renaming$new_names

##Make uniprot and gene columns, and check for multiple uniprots and genes, and NAs

#Make uniprot column

data_raw_reorder$uniprot<-data_raw_reorder$PTM.ProteinId

#Check for multiple uniprots and NAs

length(data_raw_reorder$uniprot)
length(unique(data_raw_reorder$uniprot))
length(grep(";",data_raw_reorder$uniprot))
length(which(is.na(data_raw_reorder$uniprot)))
length(which(data_raw_reorder$uniprot==""))

##Make gene column

data_raw_reorder$gene<-data_raw_reorder$PG.Genes

#Check for guplicate uniprots 

dup_indices<-grep(";",data_raw_reorder$gene)

for (i in dup_indices){
  genes<-strsplit(data_raw_reorder$PG.Genes[i],";")[[1]]
  uniprots<-strsplit(data_raw_reorder$PTM.ProteinId[i],";")[[1]]
  selected_uniprot<-data_raw_reorder$uniprot[i]
  index<-which(uniprots == selected_uniprot)
  selected_gene<-genes[index]
  data_raw_reorder$gene[i]<-selected_gene
}

#Check for missing genes

length(which(is.na(data_raw_reorder$gene)))

length(which(data_raw_reorder$gene == ""))

empty_genes<-which(is.na(data_raw_reorder$gene))

data_raw_reorder$gene[empty_genes]<-data_raw_reorder$uniprot[empty_genes]


##Make row names

data_raw_reorder$site<-paste(data_raw_reorder$PTM.SiteAA,data_raw_reorder$PTM.SiteLocation, sep = "")

data_raw_reorder$standard_name<-paste(data_raw_reorder$uniprot,
                                      data_raw_reorder$gene,
                                      data_raw_reorder$site,
                                      data_raw_reorder$PTM.Multiplicity,
                                      sep = "_")

rownames(data_raw_reorder)<-data_raw_reorder$standard_name

```


###Log2 transformation and median normalization

```{r}
## Log2 transformation

data_log2_transform<-data_raw_reorder

data_log2_transform[,9:37]<-log2(data_raw_reorder[,9:37])

##Visulaise before norm

boxplot(data_log2_transform[,9:37], las=2, pch=20, cex=0.5, cex.axis=0.5)

##Median normalization

data_norm<-data_log2_transform

medians<-apply(data_norm[,9:37], 2, FUN = "median", na.rm = TRUE)

grand_median<-median(medians)

data_norm[,9:37]<-sweep(data_norm[,9:37], 2, STATS = medians, FUN = "-")

data_norm[,9:37]<-data_norm[,9:37]+grand_median

##Visulaise after norm

boxplot(data_norm[,9:37], las=2, pch=20, cex=0.5, cex.axis=0.5)

```

###Calculate missing value
```{r}
library(naniar)

gg_miss_var(data_norm[,9:37])

vis_miss(data_norm[,9:37])
```
###Quantification
```{r}
quant_df<-data.frame("sample" = colnames(data_norm)[9:37],
                     "quant" = colSums(!is.na(data_norm[,9:37])))
quant_df["total",]<-NA
quant_df["total","sample"]<-"total"
quant_df["total","quant"]<-length(which(rowSums(!is.na(data_norm[,9:37]))>0))
quant_df$condition<-gsub("_\\d","",quant_df$sample)

ggplot(quant_df, aes(x = sample, y = quant, fill = condition)) +
  nice_theme()+
  geom_col()+
  scale_fill_manual(values = c("ctrl_bas" = "#B3B8BC",
                              "ctrl_ins" = "#E5CDCC",
                              "ctrl_thio" = "#BCCBE5",
                              "palm_bas" = "#80828a",
                              "palm_ins" = "#CC7892",
                              "palm_thio" = "#5C7AAC",
                              "total"= "black")) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))

```



###Normality check
```{r}

##check normality

library(MVN)

mvn(data_norm[,9:37],mvnTest = "mardia")

#mardia: this calculates the Mardiaâ€™s multivariate skewness and kurtosis coefficients as well as their corresponding statistical significance.


```

###Principal component analysis (PCA)
```{r}

pca<-prcomp(t(na.omit(data_norm[,9:37])))

pca_df<-as.data.frame(pca$x, stringsAsFactors = FALSE)

pca_df$condition<-gsub("_\\d$","",rownames(pca_df))

pca_df$n<-sapply(strsplit(rownames(pca_df),"_"),function(x){x[3]})

library(ggplot2)

nice_theme <- function(){
  theme(panel.background = element_blank(),
        panel.grid = element_blank(),
        axis.line.x = element_line(colour = "black", size = 0.235),
        axis.line.y = element_line(colour = "black", size = 0.235),
        axis.text.x = element_text(colour = "black", size = 7),
        axis.text.y = element_text(colour = "black", size = 7),
        axis.title.x = element_text(colour = "black", size = 7),
        axis.title.y = element_text(colour = "black", size = 7))
}

##color by condition
ggplot(pca_df, aes(x = PC1, y = PC2, colour=condition))+
  geom_point(size=1,alpha=0.5)+
  scale_color_manual(values=c("ctrl_bas" = "#A0A0A0",
                              "ctrl_ins" = "#E5CDCC",
                              "ctrl_thio" = "#BCCBE5",
                              "palm_bas" = "#0A0A0A",
                              "palm_ins" = "#CC7892",
                              "palm_thio" = "#5C7AAC"))+
  nice_theme()+
  theme(legend.key = element_blank(),
        legend.text = element_text(size = 7),
        legend.title = element_text(size = 7))

ggsave(filename = "output/PCA_condition.pdf", width = 3.5, height = 2.0)

##color by n

ggplot(pca_df, aes(x = PC1, y = PC2, colour=n))+
  geom_point(size=1,alpha=0.5)+
  scale_color_manual(values=c("1" = "#FFCCD7",
                              "2" = "#ffc425",
                              "3" = "#BFC2FF",
                              "4" = "#83C9D4",
                              "5" = "#2E8B57"))+
  nice_theme()+
  theme(legend.key = element_blank(),
        legend.text = element_text(size = 7),
        legend.title = element_text(size = 7))

ggsave(filename = "output/PCA_n.pdf", width = 3.5, height = 2.0)
```

###Correlation matrix
```{r}
cor_matrix<- cor(data_norm[,9:37], use = "pairwise.complete.obs")

library(corrplot)

library(RColorBrewer)

corrplot(cor_matrix,
         method = "color",      
         type = "upper",
         order = "hclust",
         tl.cex = 0.5*7/6,
         tl.col = "#000000",
         cl.cex = 0.5*7/6,
         cl.align.text = "l",
         col = c(rep("black",7*100),
                 colorRampPalette(brewer.pal(9, "Blues"))((300))),
         title = "Sample correlation"
         )

#I don't understand what 7*100 means.
```



###Hierarchial clustering
```{r}
##Make distance matrix

dist_matrix<-dist(t(data_norm[,9:37]))

##Make hclust object

h_clust<-hclust(dist_matrix)

##Make dendrogram

h_dend<-as.dendrogram(h_clust)

plot(h_dend)
```


###Summary statistics
```{r}
##calculate means

#set up conditions

conditions<-c("ctrl_bas","ctrl_ins","ctrl_thio","palm_bas","palm_ins","palm_thio")


#make columns

data_norm[, paste(conditions,"mean", sep = "_")]<-NA

#Loop over conditions, and calculate mean for each condition

for(condition in conditions){
  temp_data<-data_norm[, grep(condition, colnames(data_norm)[9:37])+8]
  means<-apply(temp_data, MARGIN = 1, FUN = "mean", na.rm=TRUE)
  data_norm[, paste(condition,"mean", sep = "_")]<-means
}



##calculate FCs


data_norm$ctrl_ins_Vs_ctrl_bas_log2FC<-  data_norm$ctrl_ins_mean - data_norm$ctrl_bas_mean

data_norm$palm_ins_Vs_ctrl_ins_log2FC<-  data_norm$palm_ins_mean - data_norm$ctrl_ins_mean

data_norm$palm_thio_Vs_palm_ins_log2FC<- data_norm$palm_thio_mean - data_norm$palm_ins_mean

data_norm$palm_thio_Vs_ctrl_ins_log2FC<- data_norm$palm_thio_mean - data_norm$palm_ins_mean


```



###Linear discriminant analysis (LDA)
```{r}
install.packages("caret")
library(MASS)
#library(caret)
library(ggplot2)


lda<- lda(condition ~., data_norm_t)
lda

##visualise LDA results: Histograms

# generate predictions

lda_values<-predict(lda)

# extract group and value from predictions and format as data frame

LD1hist <- data.frame(cultivar = lda_values$class, value = lda_values$x[,1])

# plot
ggplot(LD1hist, aes(value)) +
  facet_wrap(~ cultivar, ncol = 1) + # group data by `cultivar`
  geom_histogram() + # generate histograme
  theme_bw() # change default theme




# extract group and value from predictions and format as data frame
LD2hist <- data.frame(cultivar = lda_values$class, value = lda_values$x[,2])

# plot
ggplot(LD2hist, aes(value)) +
  facet_wrap(~ cultivar, ncol = 1) + 
  geom_histogram() +
  theme_bw()

##Loadings plot of discriminant functions

# use predictions as before in lda_values
# create data frame for plotting
ldascatter <- data.frame(cultivar = lda_values$class, lda = lda_values$x)

# plot:
ggplot(ldascatter, aes(lda.LD1, lda.LD2, colour = cultivar, shape = cultivar)) +
  geom_point(size = 3, alpha = 0.8) +
  xlab("LD1") +
  ylab("LD2") +
  nice_theme()+
  theme(legend.key = element_blank())

```


###Permutational analysis of variance (PERMANOVA)
```{r}
library(vegan)

data_dist<-vegdist(data_norm_t[,1:1523], method = "bray", na.rm = TRUE)

library(factoextra)

fviz_dist(data_dist)

#test assumption
dispersion <- betadisper(data_dist, group = data_norm_t$condition)

boxplot(dispersion)

set.seed(223)

adonis2(data_norm_t[,1:1523] ~ condition, data = data_norm_t, permutations = 9999)

nmds <- metaMDS(data_norm_t[,1:1523], 
                distance = "bray",
                trace = FALSE)


ordiplot(nmds, type = "n") # generate a canvas based on the `nmds` result
# add all individuals as points 
points(nmds,
       display = "sites", 
       cex = .6, # change the scale of the points
       pch = 16, # define shape of points
       col = factor(data_norm_t$condition)) 
# then, generate ellipses for grouping
ordiellipse(nmds, 
            groups = data_norm_t$condition,
            draw = "polygon",
            conf = 0.95, 
            label = TRUE)
```



```

